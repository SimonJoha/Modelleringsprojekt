<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Three.js Planetary system</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	</head>
	<body>

		<div id="container"></div>

		<!-- <script src="three.min.js"></script> -->
		<script src="three.js"></script>
		<script>
			// Lots of global variables. (This is JavaScript. No use complaining.)
			var container;
			var camera, scene, renderer;
			
			var clock = new THREE.Clock(true);
			
			var mouseX = 0, mouseY = 0;
			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;			
			
			// Object3D ("Group") nodes and Mesh nodes
			var sceneRoot = new THREE.Group();
			var block;
			var plan;
			var object; //3D
			var golv; //3D
			var acce = 0, velocity = 0, angle = 3.1415/2;
			
			function onWindowResize() 
			{
				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			
			function init() 
			{
				container = document.getElementById( 'container' );
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth/window.innerHeight, 0.1, 100 );
				camera.position.z = 10;
				scene = new THREE.Scene();

				// MESH object 3D ----------------------------------------------------
				var meshMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
				meshMaterial.wireframe = true;

				var geom = new THREE.Geometry(); 
				var v0 = new THREE.Vector3(-2,-2,-2);
				var v1 = new THREE.Vector3( 2,-2,-2);
				var v2 = new THREE.Vector3( 2,-2, 2);
				var v3 = new THREE.Vector3(-2,-2, 2);
				var v4 = new THREE.Vector3(-2, 2,-2);
				var v5 = new THREE.Vector3( 2, 2,-2);
				var v6 = new THREE.Vector3( 2, 2, 2);
				var v7 = new THREE.Vector3(-2, 2, 2);

				geom.vertices.push(v0);
				geom.vertices.push(v1);
				geom.vertices.push(v2);
				geom.vertices.push(v3);
				geom.vertices.push(v4);
				geom.vertices.push(v5);
				geom.vertices.push(v6);
				geom.vertices.push(v7);

				geom.faces.push( new THREE.Face3(0,1,2) ); // face0
				geom.faces.push( new THREE.Face3(0,2,3) ); // face0
				geom.faces.push( new THREE.Face3(1,5,6) ); // face1
				geom.faces.push( new THREE.Face3(6,2,1) ); // face1
				geom.faces.push( new THREE.Face3(2,7,3) ); // face2
				geom.faces.push( new THREE.Face3(2,6,7) ); // face2
				geom.faces.push( new THREE.Face3(0,4,5) ); // face3
				geom.faces.push( new THREE.Face3(0,5,1) ); // face3
				geom.faces.push( new THREE.Face3(0,3,4) ); // face4
				geom.faces.push( new THREE.Face3(3,7,4) ); // face4
				geom.faces.push( new THREE.Face3(4,7,5) ); // face5
				geom.faces.push( new THREE.Face3(5,7,6) ); // face5

				geom.computeFaceNormals();
				geom.computeVertexNormals();

				object = new THREE.Mesh( geom,meshMaterial);
				object.doubleSided = true;
				
				// MESH golv 3D ---------------------------------------------------
				var geometryGolv = new THREE.BoxGeometry(16,0.1,10); 
				var materialGolv = new THREE.MeshBasicMaterial({ color: 0xff0000 });
				materialGolv.wireframe = true;
				golv = new THREE.Mesh(geometryGolv, materialPlan); 
				
				
				// MESH line 2D ---------------------------------------------------
				var geometryPlan = new THREE.PlaneGeometry(20,1); 
				var materialPlan = new THREE.MeshBasicMaterial();
				materialPlan.wireframe = true;
				plan = new THREE.Mesh(geometryPlan, materialPlan); 
				
				// Top-level node
				scene.add( sceneRoot );
				
				// Sun branch
				sceneRoot.add( object ); //New node for translation transformation
				sceneRoot.add(golv); 
				
				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 0x000000 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
				window.addEventListener( 'resize', onWindowResize, false );
			}
			
			function render() 
			{			
				
				// Variabler för att räkna ut acceleration, hastighet och vinkel
				var force = 1;
				var radius = 0.1;
				var mass = 0.01;
				var length = 0.1;
				var width = 0.1;
				var gravity = 9.82;
				var inertia = mass/3*(length*length+width*width) //tröghetsmoment
				var step = 1/1000;
				
				// Set up the camera
				camera.position.x = 0;
				camera.position.y = -mouseY*10;
				camera.lookAt( scene.position );
				
				//block.position.x = 0;
				//block.position.y = -1.5; 
				
				//plan.position.x = 0;
				//plan.position.y = -3; 
				
				golv.position.x = 0;
				golv.position.y = -2.1;
				
				delta = clock.getDelta();
				
				// Perform animations
				//objectTranslation.position.x = 3.0;
				//objectTranslation.position.y = 10.0*Math.sin(delta);
				//objectSpin.rotation.y += 0.02;
				
				//Räknar ut acceleration, hastighet och vinkel
				acce = (1/inertia)*(force*radius) + gravity*mass*Math.cos(angle);
				velocity = velocity + step*acce;
				angle = angle - Math.abs(step*velocity);
				//objectTranslation.position.x = geometryBox.x*Math.cos(angle);
				//objectTranslation.position.y = objectTranslation.position.y*Math.sin(angle);
				// Render the scene
				renderer.render( scene, camera );
			}
			
			function animate() 
			{
				requestAnimationFrame( animate ); // Request to be called again for next frame
				render();
			}
			
			init();    // Set up the scene
			animate(); // Enter an infinite loop
			
		</script>
	</body>
</html>