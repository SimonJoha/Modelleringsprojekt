<!DOCTYPE html>
<html lang="en">
	<head>
		<title>main</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	</head>
	<body>

		<div id="container"></div>

		<!-- <script src="three.min.js"></script> -->
		<script src="three.js"></script>
		<script src="OrbitControls.js"></script>
		<script src="stats.min.js"></script>
		<script src="Detector.js"></script>		
		
		<script>
			
			//IT IS WORKING!! ROTATE CAM AROUND MIDDLE
			
			
			
			// Lots of global variables. (This is JavaScript. No use complaining.)
			var container;
			var stats;
			var controls; 
			var camera, scene, renderer;
			var geometry, materials, mesh, gparent, parent;
			var radius = 500, theta = 0, phi = 0;
			var pressed = {};
			
			
			var clock = new THREE.Clock(true);
			
			var mouseX = 0, mouseY = 0;
			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;			
			
			// Object3D ("Group") nodes and Mesh nodes
			var sceneRoot = new THREE.Group();
			var block;
			var plan;
			var geom;
			var v0,v1,v2,v3,v4,v5,v6,v7;
			var object; //3D
			var golv; //3D
			var block3D; 
			
			var accrotx = 0, velrotx = 0, anglerotx = Math.PI/2;
			var accroty = 0, velroty = 0, angleroty = 0;
			var accrotz = 0, velrotz = 0, anglerotz = Math.PI/2;
			
			//Translation x-led
			var accx = 0, velx = 0, posx = 0;
		
			//Translation y-led
			var accy = 0, vely = 0, posy = -1;
			
			//Translation z-led
			var accz = 0, velz = 0, posz = 0;
			var rotmatx, rotmaty, rotmatz, trans1mat, trans2mat;

			//Start value Force
			var force = new THREE.Vector3(100, 100, 100);
			var forceInit = force;
			//Define Hmin/Hmax
			var Hmin;
			var Hmax;
			




			function init() 
			{
			
			 	camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
  				//camera.position.z = 10;

  				controls = new THREE.OrbitControls( camera ); // -----------------
  				controls.addEventListener( 'change', render ); //----------------

  				scene = new THREE.Scene();
  				
				gparent = new THREE.Object3D();  //----------------
				scene.add( gparent );  //----------------

				parent = new THREE.Object3D();  //----------------
				gparent.add( parent );  //----------------

				parent.add( camera ); //----------------
				camera.position.set(0, 0, 10); //----------------

			
								
				// MESH block
				var geometryBlock = new THREE.PlaneGeometry( 2, 2 );
				var materialBlock = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: false });
				//materialBlock.wireframe = true;
				block = new THREE.Mesh( geometryBlock, materialBlock );
				
				// MESH object 3D ----------------------------------------------------
				var meshMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
				meshMaterial.wireframe = true;
				geom = new THREE.Geometry(); 
				v0 = new THREE.Vector4(-2,-2,-2, 1);
				v1 = new THREE.Vector4( 2,-2,-2, 1);
				v2 = new THREE.Vector4( 2,-2, 2, 1);
				v3 = new THREE.Vector4(-2,-2, 2, 1);
				v4 = new THREE.Vector4(-2, 2,-2, 1);
				v5 = new THREE.Vector4( 2, 2,-2, 1);
				v6 = new THREE.Vector4( 2, 2, 2, 1);
				v7 = new THREE.Vector4(-2, 2, 2, 1);
				geom.vertices.push(v0);
				geom.vertices.push(v1);
				geom.vertices.push(v2);
				geom.vertices.push(v3);
				geom.vertices.push(v4);
				geom.vertices.push(v5);
				geom.vertices.push(v6);
				geom.vertices.push(v7);
				geom.faces.push( new THREE.Face3(0,1,2) ); // face0
				geom.faces.push( new THREE.Face3(0,2,3) ); // face0
				geom.faces.push( new THREE.Face3(1,5,6) ); // face1
				geom.faces.push( new THREE.Face3(6,2,1) ); // face1
				geom.faces.push( new THREE.Face3(2,7,3) ); // face2
				geom.faces.push( new THREE.Face3(2,6,7) ); // face2
				geom.faces.push( new THREE.Face3(0,4,5) ); // face3
				geom.faces.push( new THREE.Face3(0,5,1) ); // face3
				geom.faces.push( new THREE.Face3(0,3,4) ); // face4
				geom.faces.push( new THREE.Face3(3,7,4) ); // face4
				geom.faces.push( new THREE.Face3(4,7,5) ); // face5
				geom.faces.push( new THREE.Face3(5,7,6) ); // face5
				geom.computeFaceNormals();
				geom.computeVertexNormals();
				object = new THREE.Mesh( geom,meshMaterial);
				object.doubleSided = true;
				block3D = new THREE.Object3D();
				block3D.add(object);
				block3D.matrixAutoUpdate = true;
				
				// MESH golv 3D ---------------------------------------------------
				var geometryGolv = new THREE.BoxGeometry(16,0.1,10); 
				var materialGolv = new THREE.MeshBasicMaterial({ color: 0xff0000 });
				materialGolv.wireframe = true;
				golv = new THREE.Mesh(geometryGolv, materialPlan); 
				
				// MESH line 2D ---------------------------------------------------
				var geometryPlan = new THREE.PlaneGeometry(20,1); 
				var materialPlan = new THREE.MeshBasicMaterial();
				materialPlan.wireframe = true;
				plan = new THREE.Mesh(geometryPlan, materialPlan); 
				
				// Top-level node
				scene.add( sceneRoot );
				
				// Sun branch
				sceneRoot.add( block );
				sceneRoot.add( object ); //New node for translation transformation
				sceneRoot.add(golv); 
			
				
				rotmatx = new THREE.Matrix4();
				rotmatx.identity();
				rotmaty = new THREE.Matrix4();
				rotmaty.identity();
				rotmatz = new THREE.Matrix4();
				rotmatz.identity();
				trans1mat = new THREE.Matrix4();
				trans1mat.identity();
				trans2mat = new THREE.Matrix4();
				trans2mat.identity();
				
				
				
				
				// renderer -------------------------
				renderer = new THREE.WebGLRenderer( { antialias: false } );
				renderer.setSize( window.innerWidth, window.innerHeight );

 				container = document.getElementById( 'container' );
  				container.appendChild( renderer.domElement );

  				window.addEventListener( 'resize', onWindowResize, false );
				
				
				//renderer.setClearColor( 0x000000 );
				//renderer.setPixelRatio( window.devicePixelRatio );
			}
			
			
			
			function onWindowResize() 
			{
				//windowHalfX = window.innerWidth / 2;
				//windowHalfY = window.innerHeight / 2;

			    camera.aspect = window.innerWidth / window.innerHeight;
  				camera.updateProjectionMatrix();

  				renderer.setSize( window.innerWidth, window.innerHeight );
  				render();
			}
			
			//------ PRESS KEYS --------------
			function handleDown(e) { pressed[e.keyCode] = true; }
			function handleUp(e) { pressed[e.keyCode] = false; }
			
			function handleKeys() {
   			// Left
		    if(pressed[37]) phi += 0.01;
 		    // Right
  		    if(pressed[39]) phi -= 0.01;
   			// Up
    		if(pressed[38]) theta += 0.01;
    		// Down
    		if(pressed[40]) theta -= 0.01;
			}
			
			document.onkeydown = handleDown;
			document.onkeyup = handleUp;
			
			
			function render()
      		{			

				var gravity = 9.82;	
				var step = 1/120;	
				
				// Variabler för att räkna ut acceleration, hastighet och vinkel
				//Kraftpåverkande konstanter
				var radius = 3;
				
				//Blockets konstanter  
				var mass = 5;

				var width = Math.abs(geom.vertices[3].x - geom.vertices[2].x);
 				var depth = Math.abs(geom.vertices[3].z - geom.vertices[0].z);
 				var height = Math.abs(geom.vertices[3].y - geom.vertices[7].y);
				//tröghetsmoment
				var inertiax = mass/3*(height*height+depth*depth);
				var inertiay = mass/3*(depth*depth+width*width);
				var inertiaz = mass/3*(height*height+width*width);
				
				//Konstanter mellan block och golv
				var frictionStill = 5;
				var frictionMove = 3;

				var CoR = 0.5; // ett tal mellan 0-1, studskoefficient
				
				// Set up the camera
				camera.position.x = 0;
				camera.position.y = -mouseY*10;
				//camera.lookAt( scene.position );

        	//Startposition för planets och golvets mittpunkt				
				plan.position.x = 0;
				plan.position.y = -3;
				
				golv.position.x = 0;
				golv.position.y = -2.1;
				

				//Om radie < Hmin -> tippar bakåt, Om radie > Hmax -> tippar framåt
				if(force.x != 0 || force.y != 0 || force.z != 0) //<-- HÄR SKA DET SKAPAS FÖR X, Y OCH Z -->
				{
					Hmin = (forceInit.z*height/2 - mass*gravity*width/2 - frictionStill*height/2)/forceInit.z;
					Hmax = (forceInit.z*height/2 + mass*gravity*width/2 - frictionStill*height/2)/forceInit.z;

					//console.log('Hmin = ' + Hmin + ', Hmax = ' + Hmax);
				}
				
				if (radius > Hmax) //faller framåt
				{
					//Rotation kring x-axeln, framåt
					accrotx = (1/inertiax)*(force.x*radius) + gravity*mass*Math.cos(anglerotx);
					velrotx = velrotx + step*accrotx;
					anglerotx = anglerotx - step*velrotx;
					//Rotation kring y-axeln, framåt
					accroty = (1/inertiay)*(force.y*radius) - frictionMove*velroty;
					velroty = velroty + step*accroty;
					angleroty = angleroty - step*velroty;
					//Rotation kring z-axeln, framåt
					accrotz = (1/inertiaz)*(force.z*radius) + gravity*mass*Math.cos(anglerotz);
					velrotz = velrotz + step*accrotz;
					anglerotz = anglerotz - step*velrotz;
					
					
          			//När blocket når marken i x-led --> studs 
					// <-- KOLLA PÅ ALLA VERTEX HÄR -->
					if(anglerotx < 0)
					{
						anglerotx = 0; 
						velrotx = -velrotx*CoR;
					}
					//När blocket når marken i z-led --> studs 
					//
					// <-- KOLLA PÅ ALLA VERTEX HÄR -->
					//
					if(anglerotz < 0)
					{
						anglerotz = 0; 
						velrotxz = -velrotz*CoR;
					}
				
					//Translation i x-led
					if(forceInit.x >= frictionStill)
					{
						// Beräknar accelerationen i x-led
						// Om den är i luften
						//
						//<-- KOLLA SAMTLIGA VERTEXPOSITIONERS Y-VÄRDE SÅ ATT INGA ÄR PÅ MARKEN -->
						//
						if(posy > -1){
							accx = 1/mass*(force.x);
						}else{	// Om den är på marken
							accx = 1/mass*(force.x - frictionMove*velx);
						}
						// Beräknar hastigheten i x-led
						velx = velx + step*accx;
						// Beräknar positionen i x-led
						posx = posx + step*velx;
					}
					
					//Translation i y-led
					//
					// <-- BORDE KUNNA KNUFFAS UPPÅT ÄVEN OM DEN STÅR PÅ MARKEN -->
					if(posy > -1)
					{
						accy = 1/mass*(force.y-gravity*mass);
						vely = vely + step*accy;
						posy = posy + step*vely;
						
					}
					else //Studs 
					{
						vely = -vely * CoR;	
						posy = posy + step*vely;
						
					}	
					
					//Translation i z-led
					if(forceInit.z >= frictionStill)
					{
						// Beräknar accelerationen i 2-led
						// Om den är i luften
						//
						//<-- KOLLA SAMTLIGA VERTEXPOSITIONERS Y-VÄRDE SÅ ATT INGA ÄR PÅ MARKEN -->
						//
						if(posy > -1){
							accz = 1/mass*(force.z);
						}else{	// Om den är på marken
							accz = 1/mass*(force.z - frictionMove*velz);
						}
						// Beräknar hastigheten i x-led
						velz = velz + step*accz;
						// Beräknar positionen i x-led
						posz = posz + step*velx;
					}
					
				}
				else if(radius < Hmin) //Roterar bakåt
				{
					
					m = 1;
					M = 1;
					
					//Vinkelacceleration i x-led
					accrotx = ((M+m)*(gravity*Math.sin(anglerotz)-frictionMove*velrotx)- (height*m*velrotx*Math.sin(anglerotx)+force.x)*Math.cos(anglerotx))/(height*(M+(1-Math.cos(anglerotx)*Math.cos(anglerotx))*m));
					velrotx = velrotx + step * accrotx;
					anglerotx = anglerotx + step * velrotx;
					
					//Rotation kring y-axeln
					accroty = (1/inertiay)*(force.y*radius) - frictionMove*velroty;
					velroty = velroty + step*accroty;
					angleroty = angleroty - step*velroty;
					
					//Vinkelacceleration i z-led
					accrotz = ((M+m)*(gravity*Math.sin(anglerotz)-frictionMove*velrotz)- (height*m*velrotz*Math.sin(anglerotz)+force.z)*Math.cos(anglerotz))/(height*(M+(1-Math.cos(anglerotz)*Math.cos(anglerotz))*m));
					velrotz = velrotz + step * accrotz;
					anglerotz = anglerotz + step * velrotz;
					
					// Translation x-led
					accx = ((-m*gravity*Math.sin(anglerotx)*Math.cos(anglerotx) + m*height*velrotx*velrotx*Math.sin(anglerotx)+force.x))/(M+(1-Math.cos(anglerotx)*Math.cos(anglerotx))*m) - frictionMove*velx;
					velx = velx + step*accx;
					posx = posx + step*velx;
					//Translation i y-led
					if(posy > -1)
					{
						accy = 1/mass*((Math.sin(forceangle)*force)-gravity*mass);
						vely = vely + step*accy;
						posy = posy + step*vely;
					}
          else{
						vely = -vely * CoR;	
						posy = posy + step*vely;

					}	
					
					// Translation x-led
					accz = ((-m*gravity*Math.sin(anglerotz)*Math.cos(anglerotz) + m*height*velrotz*velrotz*Math.sin(anglerotz)+force.z))/(M+(1-Math.cos(anglerotz)*Math.cos(anglerotz))*m) - frictionMove*velz;
					velz = velz + step*accz;
					posz = posz + step*velz;
					console.log(anglerotx);
									
				}
				else //Translaterar endast
				{

					//Translation i x-led
					if(forceInit.x >= frictionStill)
					{
						// Beräknar accelerationen i x-led
						// Om den är i luften
						//
						//<-- KOLLA SAMTLIGA VERTEXPOSITIONERS Y-VÄRDE SÅ ATT INGA ÄR PÅ MARKEN -->
						//
						if(posy > -1){
							accx = 1/mass*(force.x);
						}else{	// Om den är på marken
							accx = 1/mass*(force.x - frictionmove*velx);
						}
						// Beräknar hastigheten i x-led
						velx = velx + step*accx;
						// Beräknar positionen i x-led
						posx = posx + step*velx;
					}
					
					//Translation i y-led
					//
					// <-- BORDE KUNNA KNUFFAS UPPÅT ÄVEN OM DEN STÅR PÅ MARKEN -->
					if(posy > -1)
					{
						accy = 1/mass*(force.y-gravity*mass);
						vely = vely + step*accy;
						posy = posy + step*vely;
						
					}
					else //Studs 
					{
						vely = -vely * CoR;	
						posy = posy + step*vely;
						
					}	
					
					//Translation i z-led
					if(forceInit.z >= frictionStill)
					{
						// Beräknar accelerationen i 2-led
						// Om den är i luften
						//
						//<-- KOLLA SAMTLIGA VERTEXPOSITIONERS Y-VÄRDE SÅ ATT INGA ÄR PÅ MARKEN -->
						//
						if(posy > -1){
							accz = 1/mass*(force.z);
						}else{	// Om den är på marken
							accz = 1/mass*(force.z - frictionMove*velz);
						}
						// Beräknar hastigheten i x-led
						velz = velz + step*accz;
						// Beräknar positionen i x-led
						posz = posz + step*velx;
					}

				}

				console.log('Angle = ' + anglerotx);
				rotmatx.makeRotationZ(-10*step*anglerotx);
				trans1mat.makeTranslation(-2,2,-2);
				trans2mat.makeTranslation(2,-2,2);
				

				//Roterar runt z-axeln
				block.rotation.z = anglerotx;
				if(geom.vertices[1].x < 20)
				{
					for(idx = 0; idx<8; idx++)
					{
						geom.vertices[idx].applyMatrix4(trans1mat);
						geom.vertices[idx].applyMatrix4(rotmatx);
						geom.vertices[idx].applyMatrix4(trans2mat);
						
					}
				}
				
				//Uppdaterar vertice
				geom.verticesNeedUpdate = true;
				//Uppdaterar blocket
				block3D.updateMatrix();
				
				//Uppdaterar vertice
				geom.verticesNeedUpdate = true;
				//Uppdaterar blocket
				block3D.updateMatrix();
				
				rotmatx.makeRotationX(-step*anglerotx);
				rotmaty.makeRotationY(-step*angleroty);
				rotmatz.makeRotationZ(-step*anglerotz);
				trans1mat.makeTranslation(-2,2,-2);
				trans2mat.makeTranslation(2,-2,2);
				
				//Roterar runt z-axeln
				block.rotation.z = anglerotx;
				if(geom.vertices[1].x < 20)
				{
					for(idx = 0; idx<8; idx++)
					{
						geom.vertices[idx].applyMatrix4(trans1mat);
						geom.vertices[idx].applyMatrix4(rotmatx);
						geom.vertices[idx].applyMatrix4(rotmaty);
						geom.vertices[idx].applyMatrix4(rotmatz);
						geom.vertices[idx].applyMatrix4(trans2mat);
						
					}
				}
				
				//Uppdaterar vertice
				geom.verticesNeedUpdate = true;
				//Uppdaterar blocket
				block3D.updateMatrix();
				// Sätter positionen till att vara blockets x-position
				block.position.x = posx;
				// Sätter positionen till att vara blockets x-position
				block.position.y = posy;
				// Sätter kraften till 0 eftersom det endast är en impuls

				force.setX(0);
				force.setY(0);
				force.setZ(0);

        		//objectTranslation.position.y = objectTranslation.position.y*Math.sin(angle);
				// Render the scene
				
				handleKeys();//---------------------
   				gparent.rotation.y = phi; //---------------------
   				parent.rotation.x = theta; //---------------------
				renderer.render( scene, camera ); //---------------------
			}
			
			function animate() 
			{
				requestAnimationFrame( animate ); // Request to be called again for next frame
				controls.update(); //---------------------
			}
			
			
			init();    // Set up the scene
			animate(); // Enter an infinite loop
			
		</script>
	
	
	
	
	</body>
</html>