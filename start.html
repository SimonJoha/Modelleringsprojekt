<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Three.js Planetary system</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	</head>
	<body>

		<div id="container"></div>

		<!-- <script src="three.min.js"></script> -->
		<script src="three.js"></script>
		<script>
			
			// Lots of global variables. (This is JavaScript. No use complaining.)
			var container;
			var camera, scene, renderer;
			
			var clock = new THREE.Clock(true);
			
			var mouseX = 0, mouseY = 0;
			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;			
			
			// Object3D ("Group") nodes and Mesh nodes
			var sceneRoot = new THREE.Group();
			var block;
			var plan;
			var geom;
			var v0,v1,v2,v3,v4,v5,v6,v7;
			var object; //3D
			var golv; //3D
			
			var acce = 0, velocity = 0, angle = Math.PI/2;
			
			//Translation x-led
			var accx = 0, velx = 0, posx = 0;
		
			//Translation y-led
			var accy = 0, vely = 0, posy = -1;

			//Start value Force
			var force = 100;
			var forceInit = force;

			//Define Hmin/Hmax
			var Hmin;
			var Hmax;
			
			function onWindowResize() 
			{
				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			
			function init() 
			{
				container = document.getElementById( 'container' );
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth/window.innerHeight, 0.1, 100 );
				camera.position.z = 10;
				scene = new THREE.Scene();
								
				// MESH block
				var geometryBlock = new THREE.PlaneGeometry( 2, 2 );
				var materialBlock = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: false });
				//materialBlock.wireframe = true;
				block = new THREE.Mesh( geometryBlock, materialBlock );
				// MESH object 3D ----------------------------------------------------
				var meshMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
				meshMaterial.wireframe = true;
				var geom = new THREE.Geometry(); 
				var v0 = new THREE.Vector3(-2,-2,-2);
				var v1 = new THREE.Vector3( 2,-2,-2);
				var v2 = new THREE.Vector3( 2,-2, 2);
				var v3 = new THREE.Vector3(-2,-2, 2);
				var v4 = new THREE.Vector3(-2, 2,-2);
				var v5 = new THREE.Vector3( 2, 2,-2);
				var v6 = new THREE.Vector3( 2, 2, 2);
				var v7 = new THREE.Vector3(-2, 2, 2);
				geom.vertices.push(v0);
				geom.vertices.push(v1);
				geom.vertices.push(v2);
				geom.vertices.push(v3);
				geom.vertices.push(v4);
				geom.vertices.push(v5);
				geom.vertices.push(v6);
				geom.vertices.push(v7);
				geom.faces.push( new THREE.Face3(0,1,2) ); // face0
				geom.faces.push( new THREE.Face3(0,2,3) ); // face0
				geom.faces.push( new THREE.Face3(1,5,6) ); // face1
				geom.faces.push( new THREE.Face3(6,2,1) ); // face1
				geom.faces.push( new THREE.Face3(2,7,3) ); // face2
				geom.faces.push( new THREE.Face3(2,6,7) ); // face2
				geom.faces.push( new THREE.Face3(0,4,5) ); // face3
				geom.faces.push( new THREE.Face3(0,5,1) ); // face3
				geom.faces.push( new THREE.Face3(0,3,4) ); // face4
				geom.faces.push( new THREE.Face3(3,7,4) ); // face4
				geom.faces.push( new THREE.Face3(4,7,5) ); // face5
				geom.faces.push( new THREE.Face3(5,7,6) ); // face5
				geom.computeFaceNormals();
				geom.computeVertexNormals();
				object = new THREE.Mesh( geom,meshMaterial);
				object.doubleSided = true;
				
				// MESH golv 3D ---------------------------------------------------
				var geometryGolv = new THREE.BoxGeometry(16,0.1,10); 
				var materialGolv = new THREE.MeshBasicMaterial({ color: 0xff0000 });
				materialGolv.wireframe = true;
				golv = new THREE.Mesh(geometryGolv, materialPlan); 
				
				// MESH line 2D ---------------------------------------------------
				var geometryPlan = new THREE.PlaneGeometry(20,1); 
				var materialPlan = new THREE.MeshBasicMaterial();
				materialPlan.wireframe = true;
				plan = new THREE.Mesh(geometryPlan, materialPlan); 
				
				// Top-level node
				scene.add( sceneRoot );
				
				// Sun branch
				sceneRoot.add( block );
				sceneRoot.add( object ); //New node for translation transformation
				sceneRoot.add(golv); 
				
				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 0x000000 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
				window.addEventListener( 'resize', onWindowResize, false );
			}
			
			function render()
      {				
				//Hur man ändrar position på ett vertice
				//geom.vertices[2].x = 3;

				var gravity = 9.82;	
				var step = 1/120;	
				
				// Variabler för att räkna ut acceleration, hastighet och vinkel
				//Kraftpåverkande konstanter
				var radius = 0.2;
				var forceangle = 0;
				
				//Blockets konstanter  <-- ATT GÖRA: Räkna ut längden och bredden beroende på verices-->
				var mass = 5;
				var length = 1;
				var width = 1;
				var inertia = mass/3*(length*length+width*width) //tröghetsmoment
				
				//Konstanter mellan block och golv
				var frictionStill = 5;
				var frictionmove = 3;
				var CoR = 0.5; // ett tal mellan 0-1, studskoefficient
				
				// Set up the camera
				camera.position.x = 0;
				camera.position.y = -mouseY*10;
				camera.lookAt( scene.position );
				
        //Startposition för planets och golvets mittpunkt
				
				plan.position.x = 0;
				plan.position.y = -3;
				
				golv.position.x = 0;
				golv.position.y = -2.1;
				
				delta = clock.getDelta();

				//console.log(posy);
				
				//Startposition för punkt längst ner till höger
				//posy = geom.vertices[2].y;
				//posx = geom.geometry.vertices[2].position.x;
				/*for(idx = 1; idx<7; idx++)
				{
					if(geom.vertices[idx].y < posy)
					{
						posy = geom.vertices[idx].y;
					}
					if(geom.vertices[idx].x > posx)
					{
						posx = geom.vertices[idx].x;
					}
					
				}*/
				
			
				// Perform animations
				//objectTranslation.position.x = 3.0;
				//objectTranslation.position.y = 10.0*Math.sin(delta);
				//objectSpin.rotation.y += 0.02;
				
				//Räknar ut acceleration, hastighet och vinkel
				//acce = (1/inertia)*(force*radius) + gravity*mass*Math.cos(angle);
				//velocity = velocity + step*acce;
				//angle = angle - Math.abs(step*velocity);w
				//objectTranslation.position.x = geometryBox.x*Math.cos(angle);
				//Om radie < Hmin -> tippar bakåt, Om radie > Hmax -> tippar framåt
				if(force != 0){
					Hmin = (forceInit*length/2 - mass*gravity*width/2 - frictionStill*length/2)/force;
					Hmax = (forceInit*length/2 + mass*gravity*width/2 - frictionStill*length/2)/force;
					console.log('Hmin = ' + Hmin + ', Hmax = ' + Hmax);
				}
				if (radius > Hmax) //faller framåt
				{
					acce = (1/inertia)*(force*radius) + gravity*mass*Math.cos(angle);
					velocity = velocity + step*acce;
					angle = angle - step*velocity;
					
					if(angle < 0 && posy <= -1)
					{
						angle = 0; 
						velocity = -velocity*CoR;
					}
					
					//Translation i x-led
					if(Math.cos(forceangle)*forceInit >= frictionStill)
					{
						// Beräknar accelerationen i x-led
								// Om den är i luften
						if(posy > -1){
							accx = 1/mass*((Math.cos(forceangle)*force));
						}else{	// Om den är på marken
							accx = 1/mass*((Math.cos(forceangle)*force) - frictionmove*velx);
						}
						// Beräknar hastigheten i x-led
						velx = velx + step*accx;
						// Beräknar positionen i x-led
						posx = posx + step*velx;
	
					}
					
					//Translation i y-led
					if(posy > -1)
					{
						accy = 1/mass*((Math.sin(forceangle)*force)-gravity*mass);
						vely = vely + step*accy;
						posy = posy + step*vely;
						//console.log('position y-led: ' + posy);
						//window.alert('I if-sats' + posy);
					}else{
						vely = -vely * CoR;	
						posy = posy + step*vely;
						//console.log('y hastighet: ' + vely);
					}	
				}
				else if(radius < Hmin) //Roterar bakåt
				{
					
					m = 1;
					M = 1;
					//Vinkelacceleration 
					acce = ((M+m)*(gravity*Math.sin(angle)-frictionmove*velocity)- (length*m*velocity*Math.sin(angle+force))*Math.cos(angle))/(length*(M+(1-Math.cos(angle)*Math.cos(angle))*m));
					velocity = velocity + step * acce;
					angle = angle + step * velocity;

					// Translation x-led
					accx = ((-m*gravity*Math.sin(angle)*Math.cos(angle) + m*length*velocity*velocity*Math.sin(angle)+force))/(M+(1-Math.cos(angle)*Math.cos(angle))*m) - frictionmove*velx;
					velx = velx + step*accx;
					posx = posx + step*velx;

					//Translation i y-led
					if(posy > -1)
					{
						accy = 1/mass*((Math.sin(forceangle)*force)-gravity*mass);
						vely = vely + step*accy;
						posy = posy + step*vely;
						//console.log('position y-led: ' + posy);
						//window.alert('I if-sats' + posy);
					}else{
						vely = -vely * CoR;	
						posy = posy + step*vely;
					}					
				}
				else //Translaterar endast
				{
					//Insert code here
					if(Math.cos(angle)*force >= frictionStill)
					{
						acce = 1/mass*Math.cos(angle)*force - frictionMove*velocity;
						velocity = velocity + step*acce;	
					}
					
					if(angle < 0 && posy <= -1)
					{
						angle = 0; 
						velocity = -velocity*CoR*10;
					}
					
					//Translation i x-led
					if(Math.cos(forceangle)*forceInit >= frictionStill)
					{
						// Beräknar accelerationen i x-led
								// Om den är i luften
						if(posy > -1){
							accx = 1/mass*((Math.cos(forceangle)*force));
						}else{	// Om den är på marken
							accx = 1/mass*((Math.cos(forceangle)*force) - frictionmove*velx);
						}
						// Beräknar hastigheten i x-led
						velx = velx + step*accx;
						// Beräknar positionen i x-led
						posx = posx + step*velx;
	
					}
					
					//Translation i y-led
					if(posy > -1)
					{
						accy = 1/mass*((Math.sin(forceangle)*force)-gravity*mass);
						vely = vely + step*accy;
						posy = posy + step*vely;
						//console.log('position y-led: ' + posy);
						//window.alert('I if-sats' + posy);
					}else{
						vely = -vely * CoR;	
						posy = posy + step*vely;
						//console.log('studspositionen för y: ' + posy);
					}

				}
				
				//Roterar runt z-axeln
				block.rotation.z = angle;
				// Sätter positionen till att vara blockets x-position
				block.position.x = posx;
				// Sätter positionen till att vara blockets x-position
				block.position.y = posy;
				// Sätter kraften till 0 eftersom det endast är en impuls
				force = 0;

        //objectTranslation.position.y = objectTranslation.position.y*Math.sin(angle);
				// Render the scene
				renderer.render( scene, camera );
			}
			
			function animate() 
			{
				requestAnimationFrame( animate ); // Request to be called again for next frame
				render();

			}
			
			
			init();    // Set up the scene
			animate(); // Enter an infinite loop
			window.requestAnimationFrame(animate);
			
		</script>
	</body>
</html>