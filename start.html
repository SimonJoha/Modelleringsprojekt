<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Three.js Planetary system</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  </head>
  <body>

    <div id="container"></div>

    <!-- <script src="three.min.js"></script> -->
    <script src="three.js"></script>
    <script>
      
      // Lots of global variables. (This is JavaScript. No use complaining.)
      var container;
      var camera, scene, renderer;
      
      var clock = new THREE.Clock(true);
      
      var mouseX = 0, mouseY = 0;
      var windowHalfX = window.innerWidth / 2;
      var windowHalfY = window.innerHeight / 2;     
      
      // Object3D ("Group") nodes and Mesh nodes
      var sceneRoot = new THREE.Group();
      var block;
      var plan;
      var geom;
      var v0,v1,v2,v3,v4,v5,v6,v7;
      var object; //3D
      var golv; //3D
      var block3D; 
      
      //Rotation startvärden
      var accrotx = 0, velrotx = 0, anglerotx = 0;
      var accroty = 0, velroty = 0, angleroty = 0;
      var accrotz = 0, velrotz = 0, anglerotz = 0;
      
      //Translation startvärden
      var accx = 0, velx = 0, posx = 0;
      var accy = 0, vely = 0, posy = 0;
      var accz = 0, velz = 0, posz = 0;

      var rotmatx, rotmaty, rotmatz, trans1mat, trans2mat;
      //Start value Force
      var force = new THREE.Vector3(0, 0, -1000);
      var forceInit = new THREE.Vector3(0, 0, -1000);
      
      //Define Hmin/Hmax
      var Hminx;
      var Hmaxx;
      var Hminy;
      var Hmaxy;
      var Hminz;
      var Hmaxz;
      //
      var step = 1/200; 



      function onWindowResize() 
      {
        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
      }

      function translateCube(cube , translationVector ,object){
        //console.log(translationVector);
        trans1mat.makeTranslation(translationVector.x*step,translationVector.y*step,translationVector.z*step);
        
        for( index = 0; index < 8; index++){

            cube.vertices[index].applyMatrix4(trans1mat);
         
            // cube.vertices[index].setX(translationVector.x - geom.vertices[index].x);
            // cube.vertices[index].setY(translationVector.y - geom.vertices[index].y);
            // cube.vertices[index].setZ(translationVector.z - geom.vertices[index].z);

          }

        cube.verticesNeedUpdate = true;
        object.updateMatrix();
      }

    function boxOnGround(cube){
        
        var counter = 0;
        for( index = 0; index < 8; index++){

            if(cube.vertices[index].y < -2){
              counter++;
              if (counter == 3){
                return true;
              }

            }

          }
        return false;
      }


      function rotationCube(cube, rotationVector, translationVector, object){

        trans1mat.makeTranslation(translationVector.x,translationVector.y,translationVector.z);
        trans2mat.makeTranslation(-translationVector.x,-translationVector.y,-translationVector.z);
        
        rotmatx.makeRotationX(rotationVector.x*step);
        rotmaty.makeRotationY(rotationVector.y*step);
        rotmatz.makeRotationZ(rotationVector.z*step);

          for(idx = 0; idx<8; idx++)
          {
            geom.vertices[idx].applyMatrix4(trans2mat);
            geom.vertices[idx].applyMatrix4(rotmatx);
            geom.vertices[idx].applyMatrix4(rotmaty);
            geom.vertices[idx].applyMatrix4(rotmatz);
            geom.vertices[idx].applyMatrix4(trans1mat);
            
          }
          cube.verticesNeedUpdate = true;
          object.updateMatrix();
      }
      
      function init() 
      {
        container = document.getElementById( 'container' );
        camera = new THREE.PerspectiveCamera( 60, window.innerWidth/window.innerHeight, 0.1, 100 );
        camera.position.z = 10;
        scene = new THREE.Scene();
                
        // MESH block
        var geometryBlock = new THREE.PlaneGeometry( 2, 2 );
        var materialBlock = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: false });
        //materialBlock.wireframe = true;
        block = new THREE.Mesh( geometryBlock, materialBlock );
        // MESH object 3D ----------------------------------------------------
        var meshMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
        meshMaterial.wireframe = true;
        geom = new THREE.Geometry(); 
        v0 = new THREE.Vector4(-2,-2,-2, 1);
        v1 = new THREE.Vector4( 2,-2,-2, 1);
        v2 = new THREE.Vector4( 2,-2, 2, 1);
        v3 = new THREE.Vector4(-2,-2, 2, 1);
        v4 = new THREE.Vector4(-2, 2,-2, 1);
        v5 = new THREE.Vector4( 2, 2,-2, 1);
        v6 = new THREE.Vector4( 2, 2, 2, 1);
        v7 = new THREE.Vector4(-2, 2, 2, 1);
        geom.vertices.push(v0);
        geom.vertices.push(v1);
        geom.vertices.push(v2);
        geom.vertices.push(v3);
        geom.vertices.push(v4);
        geom.vertices.push(v5);
        geom.vertices.push(v6);
        geom.vertices.push(v7);
        geom.faces.push( new THREE.Face3(0,1,2) ); // face0
        geom.faces.push( new THREE.Face3(0,2,3) ); // face0
        geom.faces.push( new THREE.Face3(1,5,6) ); // face1
        geom.faces.push( new THREE.Face3(6,2,1) ); // face1
        geom.faces.push( new THREE.Face3(2,7,3) ); // face2
        geom.faces.push( new THREE.Face3(2,6,7) ); // face2
        geom.faces.push( new THREE.Face3(0,4,5) ); // face3
        geom.faces.push( new THREE.Face3(0,5,1) ); // face3
        geom.faces.push( new THREE.Face3(0,3,4) ); // face4
        geom.faces.push( new THREE.Face3(3,7,4) ); // face4
        geom.faces.push( new THREE.Face3(4,7,5) ); // face5
        geom.faces.push( new THREE.Face3(5,7,6) ); // face5
        geom.computeFaceNormals();
        geom.computeVertexNormals();
        object = new THREE.Mesh( geom,meshMaterial);
        object.doubleSided = true;
        block3D = new THREE.Object3D();
        block3D.add(object);
        block3D.matrixAutoUpdate = true;
      
        // MESH golv 3D ---------------------------------------------------
        var geometryGolv = new THREE.BoxGeometry(16,0.1,10); 
        var materialGolv = new THREE.MeshBasicMaterial({ color: 0x99FF00 });
        golv = new THREE.Mesh(geometryGolv, materialGolv); 
        
        // Top-level node
        scene.add( sceneRoot );
        
        // Sun branch
        sceneRoot.add( object ); //New node for translation transformation
        sceneRoot.add(golv); 
        
        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor( 0x000000 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );
        window.addEventListener( 'resize', onWindowResize, false );
        
        rotmatx = new THREE.Matrix4();
        rotmatx.identity();
        rotmaty = new THREE.Matrix4();
        rotmaty.identity();
        rotmatz = new THREE.Matrix4();
        rotmatz.identity();
        trans1mat = new THREE.Matrix4();
        trans1mat.identity();
        trans2mat = new THREE.Matrix4();
        trans2mat.identity();

        var startTranslation = new THREE.Vector3(0,0/step,0);
        translateCube(geom, startTranslation, block3D);
        //var startRotation = new THREE.Vector3(0 ,0 ,0);
        //rotationCube(geom, startRotation,startTranslation,block3D);
        posx = startTranslation.x;
        posy = startTranslation.y;
        posz = startTranslation.z;
      }    


      function rotationVertex(cube){

        var vertexArray = [];
        for( index = 0; index < 8; index++){

          if( cube.vertices[index].y <= -2){

            vertexArray.push(index);
            
          }
        }
        var rotVertex = vertexArray[0];
        for( arrayIndex = 0 ; arrayIndex < vertexArray.length; arrayIndex++){

          if(force.x < 0 && force.z < 0){
              if(Math.abs(force.x) > Math.abs(force.z)){
                if(cube.vertices[vertexArray[arrayIndex]].x < cube.vertices[rotVertex].x){
                  rotVertex = vertexArray[arrayIndex];
                }
              }
              else{
                if(cube.vertices[vertexArray[arrayIndex]].z < cube.vertices[rotVertex].z){
                  rotVertex = vertexArray[arrayIndex];
                }

              }
          }else if (force.x >= 0 && force.z >= 0){
            if(Math.abs(force.x) > Math.abs(force.z)){
                if(cube.vertices[vertexArray[arrayIndex]].x > cube.vertices[rotVertex].x){
                  rotVertex = vertexArray[arrayIndex];
                }
              }
              else{
                if(cube.vertices[vertexArray[arrayIndex]].z > cube.vertices[rotVertex].z){
                  rotVertex = vertexArray[arrayIndex];
                }

              }

          }else if (force.x >= 0 && force.z < 0){
            if(Math.abs(force.x) > Math.abs(force.z)){
                if(cube.vertices[vertexArray[arrayIndex]].x > cube.vertices[rotVertex].x){
                  rotVertex = vertexArray[arrayIndex];
                }
              }
              else{
                if(cube.vertices[vertexArray[arrayIndex]].z < cube.vertices[rotVertex].z){
                  rotVertex = vertexArray[arrayIndex];
                }

              }

          }else if (force.x < 0 && force.z >= 0){
            if(Math.abs(force.x) > Math.abs(force.z)){
                if(cube.vertices[vertexArray[arrayIndex]].x < cube.vertices[rotVertex].x){
                  rotVertex = vertexArray[arrayIndex];
                }
              }
              else{
                if(cube.vertices[vertexArray[arrayIndex]].z > cube.vertices[rotVertex].z){
                  rotVertex = vertexArray[arrayIndex];
                }

              }

          }

        }
        return rotVertex;

      }

      function ontheGround(cube){

        for( index = 0; index < 8; index++){

          if( cube.vertices[index].y <= -2){

            return index;
          }
        }
        return -1;
      }

      function render()
      {     
        var gravity = 9.82; 
        
        
        // Variabler för att räkna ut acceleration, hastighet och vinkel
        //Kraftpåverkande konstanter
        var radius = 3;
        
        //Blockets konstanter  
        var mass = 5;
        var width = Math.abs(geom.vertices[3].x - geom.vertices[2].x);
        var depth = Math.abs(geom.vertices[3].z - geom.vertices[0].z);
        var height = Math.abs(geom.vertices[3].y - geom.vertices[7].y);
        //tröghetsmoment
        var inertiax = mass/3*(height*height+depth*depth);
        var inertiay = mass/3*(depth*depth+width*width);
        var inertiaz = mass/3*(height*height+width*width);
        
        //Konstanter mellan block och golv
        var frictionStill = 5;
        var frictionMove = 3;
        var CoR = 0.6; // ett tal mellan 0-1, studskoefficient
        
        // Set up the camera
        camera.position.x = 0;
        camera.position.y = -mouseY*10;
        camera.lookAt( scene.position );
          //Startposition för golvets mittpunkt       
        golv.position.x = 0;
        golv.position.y = -2;

        //Checking if any vertex touched the ground
        var onGround = ontheGround(geom);
        //console.log(onGround);
        //Checking if an entire side of the box is on the ground
        var sideOnGround = boxOnGround(geom);

        var rotVertexID = rotationVertex(geom);
        //console.log('Rotation runt vertex nr ' + rotVertexID);
        
        
        //Om radie < Hmin -> tippar bakåt, Om radie > Hmax -> tippar framåt
        if(force.x != 0) //<-- HÄR SKA DET SKAPAS FÖR X, Y OCH Z -->
        {
          Hminx = (forceInit.x*height/2 - mass*gravity*width/2 - frictionStill*height/2)/forceInit.x;
          Hmaxx = (forceInit.x*height/2 + mass*gravity*width/2 - frictionStill*height/2)/forceInit.x;
          //console.log('Hmin = ' + Hmin + ', Hmax = ' + Hmax);
        }
        if(force.y != 0) //<-- HÄR SKA DET SKAPAS FÖR X, Y OCH Z -->
        {
          Hminy = (forceInit.y*height/2 - mass*gravity*width/2 - frictionStill*height/2)/forceInit.y;
          Hmaxy = (forceInit.y*height/2 + mass*gravity*width/2 - frictionStill*height/2)/forceInit.y;
          //console.log('Hmin = ' + Hmin + ', Hmax = ' + Hmax);
        }
        if(force.z != 0) //<-- HÄR SKA DET SKAPAS FÖR X, Y OCH Z -->
        {
          Hminz = (forceInit.z*height/2 - mass*gravity*width/2 - frictionStill*height/2)/forceInit.z;
          Hmaxz = (forceInit.z*height/2 + mass*gravity*width/2 - frictionStill*height/2)/forceInit.z;
          //console.log('Hmin = ' + Hmin + ', Hmax = ' + Hmax);
        }

        //console.log('radius = ' + radius + ' Hmax = ' + Hmax);
        if (radius > Hmaxx || radius > Hmaxy || radius > Hmaxz) //faller framåt
        {
          //console.log('Faller framåt');
          //Rotation kring x-axeln, framåt
          if (radius > Hmaxz){
          accrotx = (1/inertiax)*(force.x*radius) - gravity*mass*Math.cos(anglerotx);
          velrotx = velrotx + step*accrotx;
          anglerotx = anglerotx - step*velrotx;
          }
          //Rotation kring y-axeln, framåt
          
          accroty = (1/inertiay)*(force.y*radius) - frictionMove*velroty;
          velroty = velroty + step*accroty;
          angleroty = angleroty - step*velroty;
          
          //Rotation kring z-axeln, framåt
          if (radius > Hmaxx){
          accrotz = (1/inertiaz)*(force.z*radius) - gravity*mass*Math.cos(anglerotz);
          velrotz = velrotz + step*accrotz;
          anglerotz = anglerotz - step*velrotz;
          }
          
          
          //När blocket når marken i x-led --> studs 
          // <-- KOLLA PÅ ALLA VERTEX HÄR -->
          if(sideOnGround)
          {
            velrotx = -velrotx*CoR;
            console.log('velrotx = ' + velrotx);
            if(velrotx < 0.01)
            {
              velrotx = 0;
            }
          }
          //När blocket når marken i z-led --> studs 
          //
          // <-- KOLLA PÅ ALLA VERTEX HÄR -->
          //
          if(sideOnGround)
          {
            velrotz = -velrotz*CoR;
            console.log('velrotz = ' + velrotz);
            if(velrotz < 0.1)
            {
              velrotz = 0;
            }
          }
        
          //Translation i x-led
          if(forceInit.x >= frictionStill)
          {
            // Beräknar accelerationen i x-led
            // Om den är i luften
            //
            //<-- KOLLA SAMTLIGA VERTEXPOSITIONERS Y-VÄRDE SÅ ATT INGA ÄR PÅ MARKEN -->
            //
            if(onGround == -1){
              accx = 1/mass*(force.x);
            }else{  // Om den är på marken
              accx = 1/mass*(force.x - frictionMove*velx);
            }
            // Beräknar hastigheten i x-led
            velx = velx + step*accx;
            // Beräknar positionen i x-led
            posx = posx + step*velx;
          }
          
          //Translation i y-led
          //
          // <-- BORDE KUNNA KNUFFAS UPPÅT ÄVEN OM DEN STÅR PÅ MARKEN -->
          if(onGround == -1)
          {

            //console.log('jag är i luften');
            accy = 1/mass*(force.y-gravity*mass);
            vely = vely + step*accy;
            posy = posy + step*vely;
            
          }
          else //Studs 
          {
            //console.log('jag är på marken, STOPPA MIG!');
            vely = -vely * CoR; 
            posy = posy + step*vely;
            if(vely < 0.01)
            {
              vely = 0;
            }
            
          } 
          
          //Translation i z-led
          if(forceInit.z >= frictionStill)
          {
            // Beräknar accelerationen i 2-led
            // Om den är i luften
            //
            //<-- KOLLA SAMTLIGA VERTEXPOSITIONERS Y-VÄRDE SÅ ATT INGA ÄR PÅ MARKEN -->
            //
            if(onGround == -1){
              accz = 1/mass*(force.z);
            }else{  // Om den är på marken
              accz = 1/mass*(force.z - frictionMove*velz);
            }
            // Beräknar hastigheten i x-led
            velz = velz + step*accz;
            // Beräknar positionen i x-led
            posz = posz + step*velx;
          }
          
        }
        else if(radius < Hmin) //Roterar bakåt
        {
          console.log('Faller bakåt');
          m = 1;
          M = 1;
          
          //Vinkelacceleration i x-led
          accrotx = ((M+m)*(gravity*Math.sin(anglerotz)-frictionMove*velrotx)- (height*m*velrotx*Math.sin(anglerotx)+force.x)*Math.cos(anglerotx))/(height*(M+(1-Math.cos(anglerotx)*Math.cos(anglerotx))*m));
          velrotx = velrotx + step * accrotx;
          anglerotx = anglerotx + step * velrotx;
          
          //Rotation kring y-axeln
          accroty = (1/inertiay)*(force.y*radius) - frictionMove*velroty;
          velroty = velroty + step*accroty;
          angleroty = angleroty - step*velroty;
          
          //Rotation i z-led
          accrotz = ((M+m)*(gravity*Math.sin(anglerotz)-frictionMove*velrotz)- (height*m*velrotz*Math.sin(anglerotz)+force.z)*Math.cos(anglerotz))/(height*(M+(1-Math.cos(anglerotz)*Math.cos(anglerotz))*m));
          velrotz = velrotz + step * accrotz;
          anglerotz = anglerotz + step * velrotz;
          
          // Translation x-led
          accx = ((-m*gravity*Math.sin(anglerotx)*Math.cos(anglerotx) + m*height*velrotx*velrotx*Math.sin(anglerotx)+force.x))/(M+(1-Math.cos(anglerotx)*Math.cos(anglerotx))*m) - frictionMove*velx;
          velx = velx + step*accx;
          posx = posx + step*velx;
          //Translation i y-led
          if(onGround == -1)
          {
            accy = 1/mass*((Math.sin(forceangle)*force)-gravity*mass);
            vely = vely + step*accy;
            posy = posy + step*vely;
          }
          else{
            vely = -vely * CoR; 
            posy = posy + step*vely;
          } 
          
          // Translation z-led
          accz = ((-m*gravity*Math.sin(anglerotz)*Math.cos(anglerotz) + m*height*velrotz*velrotz*Math.sin(anglerotz)+force.z))/(M+(1-Math.cos(anglerotz)*Math.cos(anglerotz))*m) - frictionMove*velz;
          velz = velz + step*accz;
          posz = posz + step*velz;
          //console.log(anglerotx);
                  
        }
        else //Translaterar endast
        {
          console.log('Translaterar');
          //Translation i x-led
          // console.log(' forceInit.x = ' + forceInit.x + 'frictionStill = ' + frictionStill);
          if(forceInit.x >= frictionStill)
          {
            // Beräknar accelerationen i x-led
            // Om den är i luften
            //
            //<-- KOLLA SAMTLIGA VERTEXPOSITIONERS Y-VÄRDE SÅ ATT INGA ÄR PÅ MARKEN -->
            //
            if(onGround == -1){
              accx = 1/mass*(force.x);
            }else{  // Om den är på marken
              accx = 1/mass*(force.x - frictionMove*velx);
            }
            console.log('accx = ' + accx);
            // Beräknar hastigheten i x-led
            velx = velx + step*accx;
            // Beräknar positionen i x-led
            posx = posx + step*velx;
          }
          
          //Translation i y-led
          //
          // <-- BORDE KUNNA KNUFFAS UPPÅT ÄVEN OM DEN STÅR PÅ MARKEN -->
          if(onGround == -1)
          {
            console.log('jag är i luften');
            accy = 1/mass*(force.y-gravity*mass);
            vely = vely + step*accy;
            posy = posy + step*vely;
            
          }
          else //Studs 
          {
            console.log('jag är på marken, STOPPA MIG!');
            vely = -vely * CoR; 
            posy = posy + step*vely;
            
          } 
          
          //Translation i z-led
          if(forceInit.z >= frictionStill)
          {
            // Beräknar accelerationen i 2-led
            // Om den är i luften
            //
            //<-- KOLLA SAMTLIGA VERTEXPOSITIONERS Y-VÄRDE SÅ ATT INGA ÄR PÅ MARKEN -->
            //
            if(onGround == -1){
              accz = 1/mass*(force.z);
            }else{  // Om den är på marken
              accz = 1/mass*(force.z - frictionMove*velz);
            }
            // Beräknar hastigheten i x-led
            velz = velz + step*accz;
            // Beräknar positionen i x-led
            posz = posz + step*velx;
          }
        }

                
        //console.log('rotx = ' + velrotx + ' roty = ' + velroty + ' rotz = ' + velrotz );
        //console.log('posx = ' + posx + ' posy = ' + posy + ' posz = ' + posz );
        // console.log('onGround = ' + onGround);
        // console.log('vertex 0 position : ' + geom.vertices[0].y);
        //Rotation rund samtliga axlar
        // block.rotation.z = anglerotx;
        //console.log('rotation kring x ' + velrotx);
        rotationVector = new THREE.Vector3(velrotx,velroty,velrotz);
        if (onGround != -1) {

          rotTransVector= new THREE.Vector3(geom.vertices[rotVertexID].x, geom.vertices[rotVertexID].y, geom.vertices[rotVertexID].z);
        
          //console.log( ' onGround position ' + geom.vertices[onGround].x +' '+ geom.vertices[onGround].y + ' ' +geom.vertices[onGround].z);

        }else{
          rotTransVector= new THREE.Vector3((geom.vertices[0].x + geom.vertices[6].x)/2, (geom.vertices[0].y + geom.vertices[6].y)/2, (geom.vertices[0].z + geom.vertices[6].z)/2);
        }
        rotationCube(geom, rotationVector, rotTransVector, block3D);
        
        //Translation i samtliga led
        translationVector = new THREE.Vector3(velx,vely, velz);
        //console.log('velx = ' + velx);
        translateCube(geom, translationVector, block3D);
        
        // Sätter kraften till 0 eftersom det endast är en impuls
        force.setX(0);
        force.setY(0);
        force.setZ(0);
        //objectTranslation.position.y = objectTranslation.position.y*Math.sin(angle);
        // Render the scene
        renderer.render( scene, camera );
      }
      
      function animate() 
      {
        requestAnimationFrame( animate ); // Request to be called again for next frame
        render();
      }

      
      init();    // Set up the scene
      animate(); // Enter an infinite loop
      window.requestAnimationFrame(animate);
      
    </script>
  
  
  
  
  </body>
</html>